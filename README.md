# devops-netology

### «3.3. Операционные системы, лекция 1»
1. Какой системный вызов делает команда cd? В прошлом ДЗ мы выяснили, что cd не является самостоятельной программой, это shell builtin, поэтому запустить strace непосредственно на cd не получится. Тем не менее, вы можете запустить strace на /bin/bash -c 'cd /tmp'. В этом случае вы увидите полный список системных вызовов, которые делает сам bash при старте. Вам нужно найти тот единственный, который относится именно к cd. Обратите внимание, что strace выдаёт результат своей работы в поток stderr, а не в stdout.
    ###### chdir("/tmp")
    
2. Попробуйте использовать команду file на объекты разных типов на файловой системе. Например:

        vagrant@netology1:~$ file /dev/tty
        /dev/tty: character special (5/0)
        vagrant@netology1:~$ file /dev/sda
        /dev/sda: block special (8/0)
        vagrant@netology1:~$ file /bin/bash
        /bin/bash: ELF 64-bit LSB shared object, x86-64        
   Используя strace выясните, где находится база данных file на основании которой она делает свои догадки.
   ###### Похоже, что /usr/share/misc/magic.mgc
    openat(AT_FDCWD, "/usr/share/misc/magic.mgc", O_RDONLY) = 3
   ###### Также пытается искать в пользовательской папке
    stat("/home/vagrant/.magic.mgc", 0x7ffd65fca240) = -1 ENOENT (No such file or directory) 

3.  Предположим, приложение пишет лог в текстовый файл. Этот файл оказался удален (deleted в lsof), однако возможности сигналом сказать приложению переоткрыть файлы или просто перезапустить приложение – нет. Так как приложение продолжает писать в удаленный файл, место на диске постепенно заканчивается. Основываясь на знаниях о перенаправлении потоков предложите способ обнуления открытого удаленного файла (чтобы освободить место на файловой системе).
    ###### Мне нравятся вот такие варианты:
    
        vagrant@ubuntu-focal:~$ cp /dev/null log_file
        vagrant@ubuntu-focal:~$ cat /dev/null > log_file
    
4. Занимают ли зомби-процессы какие-то ресурсы в ОС (CPU, RAM, IO)?
    ###### Зомби-процессы освобождают ресурсы, но оставляют запись в таблице процессов
        
5. В iovisor BCC есть утилита opensnoop:

        root@vagrant:~# dpkg -L bpfcc-tools | grep sbin/opensnoop
        /usr/sbin/opensnoop-bpfcc

    На какие файлы вы увидели вызовы группы open за первую секунду работы утилиты? Воспользуйтесь пакетом bpfcc-tools для Ubuntu 20.04. Дополнительные сведения по установке.
    
   ###### в моем случае:
        vagrant@ubuntu-focal:~$ sudo /usr/sbin/opensnoop-bpfcc
        PID    COMM               FD ERR PATH
        702    vminfo              4   0 /var/run/utmp
        583    dbus-daemon        -1   2 /usr/local/share/dbus-1/system-services
        583    dbus-daemon        21   0 /usr/share/dbus-1/system-services
        583    dbus-daemon        -1   2 /lib/dbus-1/system-services
        583    dbus-daemon        21   0 /var/lib/snapd/dbus-1/system-services/
    
6. Какой системный вызов использует uname -a? Приведите цитату из man по этому системному вызову, где описывается альтернативное местоположение в /proc, где можно узнать версию ядра и релиз ОС.

    ###### <sys/utsname.h>
         Part of the utsname information is also accessible via /proc/sys/kernel/{ostype, hostname, osrelease, version,
       domainname}.      
   
7. Чем отличается последовательность команд через ; и через && в bash? Например:
        
        root@netology1:~# test -d /tmp/some_dir; echo Hi
        Hi
        root@netology1:~# test -d /tmp/some_dir && echo Hi
        root@netology1:~#
      Есть ли смысл использовать в bash &&, если применить set -e?
    ###### && - условный оператор, логическое И
    ###### ;  - разделитель последовательных команд
    Т.е. в первом случае echo выполнится вне зависимости от результата test, а во втором случае только если test будет успешным
    set -e нет смысла использовать с логическим И, т.к. эта опция выполнит выход из выполнения команд, если хотя бы одна команда вернет ненулевой статус.
    Есть смысл использовать set -e в скриптах в некоторых случаях при отладке.
    
 8. Из каких опций состоит режим bash set -euxo pipefail и почему его хорошо было бы использовать в сценариях?
 
    ###### set -e Опция предписывает bash немедленно выйти, если какая-либо команда имеет ненулевой статус выхода.
    ###### set -u влияет на переменные. При установке ссылка на любую переменную, которую вы ранее не определяли, за исключением $* и$@, является ошибкой и приводит к немедленному завершению работы программы.
    ###### set -o pipefail этот параметр предотвращает маскировку ошибок в конвейере. Если какая-либо команда в конвейере завершится неудачно, этот код возврата будет использоваться в качестве кода возврата всего конвейера.
    ###### set -x включает режим командной оболочки, в котором все выполняемые команды выводятся на терминал.
    
    В сценариях этот набор удобно было бы использовать для отладки. Мы сразу сможем задебажить код, и не допустим ошибки на продуктив.
        
 9. Используя -o stat для ps, определите, какой наиболее часто встречающийся статус у процессов в системе. В man ps ознакомьтесь (/PROCESS STATE CODES) что значат дополнительные к основной заглавной буквы статуса процессов. Его можно не учитывать при расчете (считать S, Ss или Ssl равнозначными).
    ###### самые частые у меня :
    ###### S*(S,S+,Ss,Ssl,Ss+) - Процессы, ожидающие завершения события
    ###### I*(I,I<) - бездействие пльлка ядра
    Дополнительные символы, это определенные парметры процессов, например приоритет выполнения.
                
                <    high-priority (not nice to other users)
                N    low-priority (nice to other users)
                L    has pages locked into memory (for real-time and custom IO)
                s    is a session leader
                l    is multi-threaded (using CLONE_THREAD, like NPTL pthreads do)
                +    is in the foreground process group
    